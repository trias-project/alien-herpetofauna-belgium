---
title: "Darwin Core mapping"
subtitle: "For: Checklist of alien herpetofauna of Belgium"
author:
- Lien Reyserhove
- Sanne Govaert
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/alien-scheldt-checklist/blob/master/src/dwc_mapping.Rmd).

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
```

Load libraries:

```{r message = FALSE}
library(tidyverse)      # To do data science
library(googlesheets4)  # To import data from google sheets
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
library(rgbif)
library(inborutils)
```

# Read source data

The data is maintained in [this Google Spreadsheet](https://docs.google.com/spreadsheets/d/1LeXXbry2ArK2rngsmFjz_xErwE1KwQ8ujtvHNmTVA6E/edit#gid=961223689).
Read the relevant worksheet (published as csv):

```{r read_source_data}
input_data <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTl8IEk2fProQorMu5xKQPdMXl3OQp-c0f6eBXitv0BiVFZ3JSJCde0PtbFXuETgguf6vK8b43FDX1C/pub?gid=961223689&single=true&output=csv", col_types = cols(.default = "c"))
```

Copy the source data to the repository to keep track of changes:

```{r}
write_csv(input_data, here("data", "raw", "alien-herpetofauna-checklist_dump.csv"), na = "")
```

# Preprocessing

## Tidy data

Clean dataset names:

```{r}
input_data %<>% clean_names()
```

## Match with the GBIF backboe

We screen the scientific names for potential errors by matching them to the GBIF backbone

```{r}
species_df_matched <- gbif_species_name_match(
  df = input_data, 
  name = "scientific_name")
```
```{r}
species_df_matched %>% 
    select(scientific_name, scientificName, status, confidence, synonym, matchType) %>% 
    filter(matchType != "EXACT") %>% 
    arrange(matchType)
```

## Generate Taxon ID

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. Here we create one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name and kingdom (that will remain the same as long as scientific name and kingdom remain the same):

```{r}
vdigest <- Vectorize(digest) # Vectorize digest function to work with vectors
input_data %<>% mutate(taxon_id = paste(
  "alien-herpetofauna-belgium",
  "taxon",
  vdigest(paste(scientific_name, kingdom), algo = "md5"),
  sep = ":"
))
```

# Darwin Core mapping

## Taxon core

Create a dataframe with unique taxa only (ignoring multiple distribution rows). Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

```{r}
taxon <-
  input_data %>%
  distinct(taxon_id, .keep_all = TRUE) %>%
  mutate(
    language = "en",
    license = "http://creativecommons.org/publicdomain/zero/1.0/",
    rightsHolder = "INBO",
    accessRights = "https://www.inbo.be/en/norms-data-use",
    datasetID = "https://doi.org/10.15468/pnxu4c",
    institutionCode = "INBO",
    datasetName = "Checklist of alien herpetofauna of Belgium",
    taxonID = taxon_id,
    scientificName = scientific_name,
    kingdom = kingdom,
    phylum = phylum,
    class = class,
    order = order,
    family = family,
    genus = genus,
    taxonRank = taxon_rank,
    nomenclaturalCode = nomenclatural_code,
    .keep = "none"
  ) %>% 
  arrange(taxonID) %>% 
  select(
    "language", "license", "rightsHolder", "accessRights", "datasetID",
    "institutionCode", "datasetName", "taxonID", "scientificName", "kingdom", 
    "phylum", "class", "order", "family", "genus", "taxonRank",
    "nomenclaturalCode"
  )
```

## Create distribution extension

Create a dataframe with all data (including multiple distributions). Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

```{r}
distribution <-
  input_data %>%
  # mutate(
  #   introduction_pathway_1 =
  #     ifelse(is.na(introduction_pathway_1), "no value", introduction_pathway_1)
  # ) %>%
  # pivot_longer(
  #   names_to = "key",
  #   values_to = "pathway",
  #   starts_with("introduction_pathway"),
  #   values_drop_na = TRUE) %>%
  mutate(
    taxonID = taxon_id,
    locationID = case_when(
      location == "Flanders" ~ "ISO_3166-2:BE-VLG",
      location == "Wallonia" ~ "ISO_3166-2:BE-WAL",
      location == "Brussels" ~ "ISO_3166-2:BE-BRU"
    ),
    locality = case_when(
      location == "Flanders" ~ "Flemish Region",
      location == "Wallonia" ~ "Walloon Region",
      location == "Brussels" ~ "Brussels-Capital Region"
    ),
    countryCode = country_code,
    occurrenceStatus = occurrence_status,
    establishmentMeans = establishment_means,
    #degreeOfEstablishment = degree_of_establishment,
    # pathway = case_when(
    #   pathway == "no value" ~ NA,
    #   .default = pathway
    # ),
    eventDate = case_when(
      is.na(date_first_observation) & is.na(date_last_observation) ~ "",
      is.na(date_first_observation) ~ date_last_observation,
      date_first_observation == date_last_observation ~ date_first_observation,
      TRUE ~ paste(date_first_observation, date_last_observation, sep = "/")
    ),
    # eventDate = case_when(
    #   is.na(date_first_observation) & is.na(date_last_observation) ~ NA,
    #   is.na(date_first_observation) & !is.na(date_last_observation) ~ paste0("/", date_last_observation),
    #   !is.na(date_first_observation) & is.na(date_last_observation) ~ paste0(date_first_observation, "/"),
    #   !is.na(date_first_observation) & !is.na(date_last_observation) ~ paste(date_first_observation, date_last_observation, sep = "/")
    # ),
    source = source,
    occurrenceRemarks = occurrence_remarks
  ) %>%
  select(
    "taxonID", "locationID", "locality", "countryCode", "occurrenceStatus",
    "establishmentMeans", #"degreeOfEstablishment", #"pathway",
    "eventDate",
    "source", "occurrenceRemarks"
  ) %>%
  arrange(taxonID)
```

## Species profile extension

In this extension we will express broad habitat characteristics of the species (e.g. `isTerrestrial`).

Create a dataframe with unique taxa only (ignoring multiple distribution rows).
Only keep records for which `terrestrial`, `marine` and `freshwater` is not empty.

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

```{r}
species_profile <-
  input_data %>%
  distinct(taxon_id, .keep_all = TRUE) %>% 
  filter(
    !is.na(terrestrial) |
      !is.na(marine) |
      !is.na(freshwater)
  ) %>% 
  mutate(
    .keep = "none",
    taxonID = taxon_id,
    isMarine = marine,
    isFreshwater = freshwater,
    isTerrestrial = terrestrial
  ) %>% 
  arrange(taxonID)
```

## Create description extension

In the description extension we want to include several important characteristics (hereafter referred to as descriptors) about the species:

* Degree of establishment
* Introduction pathway
* Native range

The structure of the description extension is slightly different from the other core/extension files: information for a specific taxon (linked to taxonID) is provided in **multipele** lines within the csv file: one line per taxon per descriptor. In this way, we are able to include multipele descriptors for each species. 

For each descriptor, we create a separate dataframe to process the specific information. We always specify *which descriptor* we map (`type` column) and its *specific content* (`description` column). After the mapping of these Darwin Core terms `type` and `value`, we merge the dataframes to generate one single description extension. We then continue the mapping process by adding the other Darwin Core terms (which content is independent of the type of descriptor, such as `language`).

### Degree of establishment

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
degree_of_establishment <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

Show unique values:

```{r}
degree_of_establishment %>%
  distinct(degree_of_establishment) %>%
  arrange(degree_of_establishment)
```

Map `description`

```{r}
degree_of_establishment %<>% mutate(description = degree_of_establishment) 
```

Map `type`

```{r}
degree_of_establishment %<>% mutate(type = "degree of establishment") 
```

### Pathway of introduction

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
introduction_pathway <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

Show unique values:

```{r}
introduction_pathway %>%
  distinct("old_introduction_pathway_will_be_deleted") %>%
  arrange("old_introduction_pathway_will_be_deleted")
```

Remove records for which `introduction_pathway` is `NA`:

```{r}
introduction_pathway %<>% 
  filter(!is.na("old_introduction_pathway_will_be_deleted")) 
```

`introduction_pathway` contains multiple values (currently not more than 3), so we separate it in 2 columns:

```{r}
introduction_pathway %<>% separate("old_introduction_pathway_will_be_deleted", 
  into = c("pathway_1", "pathway_2", "pathway_3"),
  sep = "\\s\\|\\s",
  remove = FALSE)
```

Gather in a `key` and `value` column:

```{r}
introduction_pathway %<>% gather(
  key, value,
  pathway_1, pathway_2,pathway_3,
  na.rm = TRUE, # Also removes records for which there is no native_range_1
  convert = FALSE
)
```

Add prefix `cbd_2014_pathway:`

```{r}
introduction_pathway %<>% mutate(mapped_value = paste ("cbd_2014_pathway", value, sep = ":"))
```

Sumarize `value`

```{r}
introduction_pathway %>%
  group_by(mapped_value) %>%
  count()
```

Map `description`

```{r}
introduction_pathway %<>% mutate(description = mapped_value) 
```

Map `type` field

```{r}
introduction_pathway %<>% mutate(type = "pathway") 
```



### Native range

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
native_range <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```


Show unique values:

```{r}
native_range %>%
  distinct(native_range) %>%
  arrange(native_range)
```

Remove records for which `native_range` = `NA`

```{r}
native_range %<>% filter(!is.na(native_range))
```

Add `description` field

```{r}
native_range %<>% mutate(description = native_range) 
```

Add `type` field

```{r}
native_range %<>% mutate(type = "native range") 
```

### Union description

Union native range and degree of establishment:

```{r start_description_ext}
description_ext <- bind_rows(degree_of_establishment, introduction_pathway, native_range)
```

Map the data to [Taxon Description](http://rs.gbif.org/extension/gbif/1.0/description.xml):

#### taxonID

```{r}
description_ext %<>% mutate(dwc_taxonID = taxon_id)
```

#### description

```{r}
description_ext %<>% mutate(dwc_description = description)
```

#### type

```{r}
description_ext %<>% mutate(dwc_type = type)
```

#### language

```{r}
description_ext %<>% mutate(dwc_language = "en")
```

# Post-processing

Remove the original columns for each of the generated files:

```{r}
description_ext %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(description_ext) <- str_remove(colnames(description_ext), "dwc_")
```

Sort on `taxonID` to group description information per taxon:

```{r}
description_ext %<>% arrange(taxonID)
```


Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
write_csv(species_profile, here("data", "processed", "speciesprofile.csv"), na = "")
write_csv(description_ext, here("data", "processed", "description.csv"), na = "")
```


